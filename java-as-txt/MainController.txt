package TartarusCore.TxtConverter;

import javafx.application.Platform;
import javafx.fxml.FXML;
import javafx.scene.control.CheckBox;
import javafx.scene.control.ComboBox;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextField;
import javafx.scene.layout.HBox;
import javafx.stage.DirectoryChooser;
import javafx.stage.Stage;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;

public class MainController {

    private static final String OUTPUT_DIR_NAME = "_ConvertedToTxt";
    private final Map<String, String> presets = new LinkedHashMap<>();

    private Stage stage;
    private double xOffset = 0;
    private double yOffset = 0;

    @FXML private TextField sourceDirField;
    @FXML private TextField extensionsField;
    @FXML private ComboBox<String> presetComboBox;
    @FXML private TextArea logArea;
    @FXML private HBox titleBar;
    @FXML private CheckBox generateStructureFileCheckbox;
    // >>> НОВЫЙ ЭЛЕМЕНТ: Связь с полем для игнорируемых папок <<<
    @FXML private TextField ignoredFoldersField;

    public void setStage(Stage stage) {
        this.stage = stage;
    }

    @FXML
    public void initialize() {
        setupPresets();
        setupPresetListener();
        setupWindowDrag();
        // >>> Устанавливаем значение по умолчанию для нового поля <<<
        ignoredFoldersField.setText("Library, Temp, obj, bin, ProjectSettings, Logs, Ignored");
        log("Приложение готово к работе.");
        log("Папки по умолчанию для игнорирования: Library, Temp, obj, bin, ProjectSettings, Logs");
    }

    // >>> ИЗМЕНЕНИЕ: Добавлен пресет для Unity <<<
    private void setupPresets() {
        presets.put("Вручную", "");
        presets.put("Godot Engine", "gd, tscn, tres, gdshader, godot");
        // Файлы .unity и .prefab намеренно исключены, как ты и просил.
        presets.put("Unity Engine", "cs, shader, cginc, txt, json, xml, asmdef, asset, inputactions");
        presets.put("Java (Maven/Gradle)", "java, xml, properties, fxml, gradle, groovy");
        presets.put("Web Frontend", "html, css, js, ts, scss, json");
        presetComboBox.getItems().addAll(presets.keySet());
        // Выбираем Unity по умолчанию, так как это последнее изменение.
        presetComboBox.getSelectionModel().select("Unity Engine");
    }

    // >>> ИЗМЕНЕНИЕ: Теперь передаем больше параметров в фоновый поток <<<
    @FXML
    private void handleConvert() {
        String sourceDirPath = sourceDirField.getText();
        if (sourceDirPath == null || sourceDirPath.isBlank()) {
            log("Ошибка: Не выбрана папка с исходниками!");
            return;
        }

        List<String> extensions = getExtensions();
        if (extensions.isEmpty()) {
            log("Ошибка: Не указаны расширения для конвертации!");
            return;
        }

        List<String> ignoredFolders = getIgnoredFolders();
        boolean generateStructureFile = generateStructureFileCheckbox.isSelected();

        new Thread(() -> convertFilesInBackground(sourceDirPath, extensions, ignoredFolders, generateStructureFile)).start();
    }

    // >>> ГЛАВНЫЙ ИЗМЕНЕННЫЙ МЕТОД: Добавлена логика игнорирования папок <<<
    private void convertFilesInBackground(String sourceDirPath, List<String> extensions, List<String> ignoredFolders, boolean generateStructureFile) {
        Platform.runLater(() -> logArea.clear());
        log("Начало конвертации...");
        if (!ignoredFolders.isEmpty()) {
            log("Игнорируются папки: " + String.join(", ", ignoredFolders));
        }
        log("Файлы .md будут скопированы без изменений.");
        if (generateStructureFile) {
            log("Генерация файла структуры включена.");
        }

        Path sourcePath = Paths.get(sourceDirPath);
        Path outputPath = sourcePath.resolve(OUTPUT_DIR_NAME);
        List<Path> processedFileRelativePaths = new ArrayList<>();

        try {
            prepareOutputDirectory(outputPath);

            try (var stream = Files.walk(sourcePath)) {
                List<Path> filesToConvert = stream
                        .filter(Files::isRegularFile)
                        // Фильтр 1: Не трогаем нашу же выходную папку
                        .filter(p -> !p.startsWith(outputPath))
                        // Фильтр 2: Проверяем, не находится ли файл в игнорируемой папке
                        .filter(path -> {
                            if (ignoredFolders.isEmpty()) {
                                return true; // Если список игнора пуст, пропускаем все.
                            }
                            // Проверяем каждую часть пути (каждую папку)
                            for (Path part : sourcePath.relativize(path)) {
                                if (ignoredFolders.contains(part.toString().toLowerCase())) {
                                    return false; // Нашли игнорируемую папку в пути, файл пропускаем.
                                }
                            }
                            return true; // Путь чист.
                        })
                        // Фильтр 3: Проверяем расширения, как и раньше
                        .filter(p -> {
                            String fileName = p.getFileName().toString().toLowerCase();
                            if (fileName.endsWith(".md")) {
                                return true;
                            }
                            int dotIndex = fileName.lastIndexOf('.');
                            if (dotIndex > 0) {
                                String extension = fileName.substring(dotIndex + 1);
                                return extensions.contains(extension);
                            }
                            return extensions.contains(fileName);
                        })
                        .collect(Collectors.toList());

                if (filesToConvert.isEmpty()) {
                    log("Файлы для конвертации не найдены (с учетом фильтров).");
                    return;
                }

                log("Найдено файлов для обработки: " + filesToConvert.size());
                for (Path sourceFile : filesToConvert) {
                    String sourceFileName = sourceFile.getFileName().toString();

                    String destFileName;
                    if (sourceFileName.toLowerCase().endsWith(".md")) {
                        destFileName = sourceFileName;
                    } else {
                        destFileName = sourceFileName + ".txt";
                    }

                    Path destFile = outputPath.resolve(destFileName);
                    Files.copy(sourceFile, destFile, StandardCopyOption.REPLACE_EXISTING);
                    log("Скопировано: " + sourceFileName + " -> " + destFileName);

                    processedFileRelativePaths.add(sourcePath.relativize(sourceFile));
                }

                if (generateStructureFile && !processedFileRelativePaths.isEmpty()) {
                    generateStructureReport(outputPath, sourcePath.getFileName().toString(), processedFileRelativePaths);
                }

                log("\n====================\nКОНВЕРТАЦИЯ ЗАВЕРШЕНА\n====================");
                log("Все файлы сохранены в папке: " + outputPath);

            }
        } catch (IOException e) {
            log("КРИТИЧЕСКАЯ ОШИБКА: " + e.getMessage());
            e.printStackTrace();
        }
    }

    // >>> НОВЫЙ МЕТОД для получения списка игнорируемых папок <<<
    private List<String> getIgnoredFolders() {
        String rawText = ignoredFoldersField.getText();
        if (rawText == null || rawText.isBlank()) {
            return Collections.emptyList();
        }
        return Arrays.stream(rawText.split(","))
                .map(String::trim)
                .map(String::toLowerCase)
                .filter(s -> !s.isEmpty())
                .collect(Collectors.toList());
    }

    // Остальные методы без изменений...
    private void setupWindowDrag() {
        titleBar.setOnMousePressed(event -> {
            xOffset = event.getSceneX();
            yOffset = event.getSceneY();
        });
        titleBar.setOnMouseDragged(event -> {
            stage.setX(event.getScreenX() - xOffset);
            stage.setY(event.getScreenY() - yOffset);
        });
    }

    @FXML
    private void handleMinimize() {
        if (stage != null) {
            stage.setIconified(true);
        }
    }

    @FXML
    private void handleClose() {
        Platform.exit();
    }

    private void setupPresetListener() {
        presetComboBox.getSelectionModel().selectedItemProperty().addListener((options, oldValue, newValue) -> {
            if (newValue != null && !newValue.equals("Вручную")) {
                extensionsField.setText(presets.get(newValue));
                log("Выбран пресет '" + newValue + "'. Расширения установлены.");
            }
        });
        extensionsField.setText(presets.get(presetComboBox.getSelectionModel().getSelectedItem()));
    }

    @FXML
    private void handleSelectSource() {
        DirectoryChooser directoryChooser = new DirectoryChooser();
        directoryChooser.setTitle("Выберите папку проекта");
        File selectedDirectory = directoryChooser.showDialog(getStage());

        if (selectedDirectory != null) {
            sourceDirField.setText(selectedDirectory.getAbsolutePath());
            log("Выбрана папка с исходниками: " + selectedDirectory.getAbsolutePath());
        }
    }

    private void generateStructureReport(Path outputPath, String rootDirName, List<Path> relativePaths) throws IOException {
        log("Создание файла структуры...");
        Path reportFile = outputPath.resolve("_FileStructure.md");

        Collections.sort(relativePaths);

        StringBuilder reportContent = new StringBuilder();
        reportContent.append("# Структура скопированных файлов\n\n");
        reportContent.append("Отчет сгенерирован: `").append(LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))).append("`\n\n");
        reportContent.append("```\n");
        reportContent.append(rootDirName).append("\n");

        for (Path path : relativePaths) {
            StringBuilder prefix = new StringBuilder();
            if (path.getParent() != null) {
                for (int i = 0; i < path.getNameCount() - 1; i++) {
                    prefix.append("│   ");
                }
            }
            reportContent.append(prefix.toString()).append("├── ").append(path.getFileName().toString()).append("\n");
        }

        reportContent.append("```\n");

        Files.writeString(reportFile, reportContent.toString(), StandardCharsets.UTF_8);
        log("Файл структуры успешно создан: " + reportFile.getFileName());
    }

    private void prepareOutputDirectory(Path outputPath) throws IOException {
        if (Files.exists(outputPath)) {
            log("Очистка старой папки: " + outputPath);
            try (var stream = Files.walk(outputPath)) {
                stream.sorted(Comparator.reverseOrder())
                        .map(Path::toFile)
                        .forEach(File::delete);
            }
        }
        Files.createDirectories(outputPath);
        log("Папка для результатов готова: " + outputPath);
    }

    private List<String> getExtensions() {
        String rawText = extensionsField.getText();
        if (rawText == null || rawText.isBlank()) {
            return Collections.emptyList();
        }
        return Arrays.stream(rawText.split(","))
                .map(String::trim)
                .map(String::toLowerCase)
                .filter(s -> !s.isEmpty())
                .collect(Collectors.toList());
    }

    private void log(String message) {
        Platform.runLater(() -> logArea.appendText(message + "\n"));
    }

    private Stage getStage() {
        if (stage != null) {
            return stage;
        }
        return (Stage) sourceDirField.getScene().getWindow();
    }
}